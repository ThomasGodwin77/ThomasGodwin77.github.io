<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Орбитальный Страж</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-bg: #0D0F1A;
            --secondary-bg: #1A1C2A;
            --accent-color: #00A2FF;
            --light-accent-color: #87CEEB;
            --text-color: #E0E0E0;
            --danger-color: #FF4141;
            --asteroid-color-default: #A0A0A0;
            --font: 'Inter', sans-serif;
            --shadow: 0px 8px 25px rgba(0, 162, 255, 0.2);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--primary-bg);
            color: var(--text-color);
            font-family: var(--font);
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none; 
        }

        .game-wrapper {
            width: 100%;
            height: 100%;
            max-width: 450px; 
            max-height: 900px;
            background-color: var(--primary-bg);
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            transition: background-color 0.5s ease;
        }

        /* --- Стили Экранов --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
            opacity: 0;
            visibility: hidden;
            transform: scale(1.05);
            transition: opacity 0.5s ease, transform 0.5s ease, visibility 0.5s;
            z-index: 10;
        }

        .screen.active {
            opacity: 1;
            visibility: visible;
            transform: scale(1);
        }
        
        #game-screen {
            padding: 0;
            justify-content: flex-start;
        }
        
        .page-header {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 15;
        }

        /* --- Главное Меню --- */
        #main-menu .title {
            font-size: clamp(2.5rem, 10vw, 3.5rem);
            font-weight: 900;
            color: white;
            letter-spacing: -2px;
            text-shadow: 0 0 15px var(--accent-color);
            margin-bottom: 60px;
            text-align: center;
        }

        .menu-buttons-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .menu-buttons {
            display: flex;
            gap: 20px;
        }

        /* --- Общие стили кнопок --- */
        .btn {
            background: transparent;
            border: 2px solid var(--accent-color);
            color: var(--accent-color);
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            user-select: none;
        }

        .btn:hover, .btn:focus {
            background-color: var(--accent-color);
            color: var(--primary-bg);
            box-shadow: var(--shadow);
            transform: translateY(-3px);
        }
        
        .btn:active {
            transform: translateY(0px);
        }
        
        .btn.btn-danger {
            border-color: var(--danger-color);
            color: var(--danger-color);
        }
        .btn.btn-danger:hover {
            background-color: var(--danger-color);
            color: var(--primary-bg);
        }


        .btn-icon {
            background: var(--secondary-bg);
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }

        .btn-icon svg {
            width: 28px;
            height: 28px;
            fill: var(--text-color);
            transition: fill 0.3s ease;
        }
        
        .btn-icon:hover {
            background: var(--accent-color);
            box-shadow: var(--shadow);
        }

        .btn-icon:hover svg {
            fill: var(--primary-bg);
        }
        
        /* --- Игровой Экран --- */
        #game-canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .game-ui {
            position: relative;
            z-index: 5;
            width: 100%;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .game-ui-top-row {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }


        #score-display, #pause-btn {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #score-display {
            font-size: 2.5rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 0 10px rgba(255,255,255,0.7);
        }
        
        #pause-btn {
            background: rgba(26, 28, 42, 0.7);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #fuel-bar-container {
            width: 100%;
            height: 16px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            display: none;
            margin-top: 10px;
            position: relative;
            transition: transform 0.1s ease-out, opacity 0.5s ease;
            opacity: 0;
        }
        #fuel-bar {
            width: 100%;
            height: 100%;
            background-color: #FFD700;
            border-radius: 8px;
            transition: width 0.1s linear, background-color 0.2s ease;
        }
        
        /* --- Модальные окна --- */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 15, 26, 0.7);
            backdrop-filter: blur(10px);
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        .modal.active {
            opacity: 1;
            visibility: visible;
        }
        
        .modal-content {
            background: var(--secondary-bg);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            width: 90%;
            max-width: 350px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        
        .modal.active .modal-content {
            transform: scale(1);
        }

        .modal-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 20px;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 30px;
        }
        
        #final-score, #final-best, #final-loot {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }
        #final-score span, #final-best span, #final-loot span {
            font-weight: 700;
            color: var(--accent-color);
        }
        
        /* --- Экраны --- */
        .page-content {
            width: 100%;
            text-align: left;
            margin-bottom: 20px;
            max-height: 70vh;
            overflow-y: hidden;
            padding: 0 10px;
        }
        
        #dev-settings-screen .page-content {
            overflow-y: auto;
        }

        #level-select-screen .modal-title {
            margin-top: 60px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        .stat-item {
            background: var(--secondary-bg);
            padding: 20px;
            border-radius: 15px;
        }
        
        .stat-item h3 {
            font-size: 1rem;
            color: var(--light-accent-color);
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        
        .stat-item p {
            font-size: 2.2rem;
            font-weight: 700;
        }

        .rules-content p {
            font-size: 1.1rem;
            line-height: 1.7;
            margin-bottom: 20px;
        }

        .settings-list {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--secondary-bg);
            padding: 15px 20px;
            border-radius: 15px;
        }

        .setting-item span, .setting-item label {
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--accent-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .radio-group label {
            display: block;
            margin: 10px 0;
            background-color: var(--primary-bg);
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.3s;
        }
        .radio-group input:checked + label {
            border-color: var(--accent-color);
        }
        .radio-group input {
            display: none;
        }

        /* --- Выбор уровня --- */
        .level-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            width: 100%;
        }
        .level-btn {
            aspect-ratio: 1 / 1;
            background-color: var(--secondary-bg);
            border: 2px solid transparent;
            border-radius: 15px;
            color: var(--text-color);
            font-size: 2rem;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.1s ease, border-color 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .level-btn:hover:not(.locked) {
             border-color: var(--accent-color);
        }
        .level-btn:active:not(.locked) {
            transform: scale(0.95);
        }
        .level-btn.locked {
            background-color: #2a2d3f;
            color: #5b5f7e;
            cursor: not-allowed;
        }

    </style>
</head>
<body>
    <div class="game-wrapper">
        <!-- Главное Меню -->
        <div id="main-menu" class="screen active">
            <h1 class="title">Орбитальный Страж</h1>
            <div class="menu-buttons-wrapper">
                <button id="play-btn" class="btn">Играть</button>
                <div class="menu-buttons">
                     <button id="rules-btn-menu" class="btn-icon" aria-label="Правила">
                         <svg viewBox="0 0 24 24"><path d="M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" /></svg>
                    </button>
                    <button id="settings-btn-menu" class="btn-icon" aria-label="Настройки">
                        <svg viewBox="0 0 24 24"><path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.98C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.98L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.98Z" /></svg>
                    </button>
                    <button id="stats-btn-menu" class="btn-icon" aria-label="Статистика">
                        <svg viewBox="0 0 24 24"><path d="M22,21H2V3H4V19H6V10H10V19H12V6H16V19H18V14H22V21Z" /></svg>
                    </button>
                </div>
                 <button id="dev-settings-btn-menu" class="btn-icon" aria-label="Инструменты разработчика" style="font-size: 1.2rem; font-weight: 700; color: var(--text-color);">
                    DM
                </button>
            </div>
        </div>

        <!-- Игровой экран -->
        <div id="game-screen" class="screen">
            <div class="game-ui">
                <div class="game-ui-top-row">
                    <div id="score-display">0.00</div>
                    <button id="pause-btn" class="btn-icon" aria-label="Пауза">
                        <svg viewBox="0 0 24 24"><path d="M14,19H18V5H14M6,19H10V5H6V19Z" /></svg>
                    </button>
                </div>
                 <div id="fuel-bar-container">
                    <div id="fuel-bar"></div>
                </div>
            </div>
            <canvas id="game-canvas"></canvas>
        </div>

        <!-- Экраны -->
        <div id="level-select-screen" class="screen">
            <div class="page-header">
                <button class="btn-icon btn-back" aria-label="Назад">
                    <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
                </button>
            </div>
            <h2 class="modal-title">Выберите уровень</h2>
            <div class="page-content">
                <div id="level-grid" class="level-grid"></div>
            </div>
        </div>
        
        <div id="stats-screen" class="screen">
             <h2 class="modal-title">Статистика</h2>
             <div class="page-content">
                 <div class="stats-grid">
                     <div class="stat-item">
                         <h3>Рекорд выживания</h3>
                         <p id="best-time-stat">0.00</p>
                     </div>
                     <div class="stat-item">
                         <h3>Количество попыток</h3>
                         <p id="attempts-stat">0</p>
                     </div>
                 </div>
             </div>
             <button class="btn btn-back">Назад</button>
        </div>

        <div id="rules-screen" class="screen">
             <h2 class="modal-title">Правила игры</h2>
             <div class="page-content rules-content">
                <p>🚀 <b>Цель:</b> выжить как можно дольше, управляя ракетой на орбите планет.</p>
                <p>🕹️ <b>Управление:</b> нажмите и удерживайте экран (или левую кнопку мыши), чтобы активировать двигатели и отдалиться от планет.</p>
                <p>💥 <b>Опасности:</b> избегайте столкновения с планетами, пролетающими астероидами и не улетайте слишком далеко за пределы игровой зоны!</p>
             </div>
             <button class="btn btn-back">Назад</button>
        </div>
        
        <div id="settings-screen" class="screen">
             <h2 class="modal-title">Настройки</h2>
             <div class="page-content">
                <div class="settings-list">
                    <div class="setting-item">
                        <span>Музыка</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="music-toggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting-item">
                        <span>Звуки</span>
                         <label class="toggle-switch">
                            <input type="checkbox" id="sound-toggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
             </div>
             <button class="btn btn-back">Назад</button>
        </div>

        <div id="dev-settings-screen" class="screen">
             <h2 class="modal-title">Инструменты разработчика</h2>
             <div class="page-content">
                <div class="settings-list">
                    <button id="reset-settings-btn" class="btn btn-danger" style="width:100%; margin-bottom: 10px;">Сбросить все настройки</button>
                    
                    <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                        <span>Регулятор скорости: <span id="speed-regulator-value">100%</span></span>
                        <input type="range" id="speed-regulator-slider" min="0.2" max="1" step="0.01" value="1" style="width: 100%;">
                    </div>
                    
                    <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                        <span>Режим управления</span>
                         <div class="radio-group" id="control-mode-group">
                            <input type="radio" id="control-mode-1" name="controlMode" value="mode1" checked><label for="control-mode-1">Режим #1 (Отталкивание)</label>
                            <input type="radio" id="control-mode-2" name="controlMode" value="mode2"><label for="control-mode-2">Режим #2 (Вперед/Назад)</label>
                         </div>
                    </div>
                    <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                        <span>Множитель тяги в Режиме#2: <span id="mode2-thrust-value">100%</span></span>
                        <input type="range" id="mode2-thrust-slider" min="0" max="1" step="0.01" value="1" style="width: 100%;">
                    </div>
                     <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                        <span>Множитель астероидов: <span id="asteroid-amount-value">100%</span></span>
                        <input type="range" id="asteroid-amount-slider" min="0.5" max="5" step="0.1" value="1" style="width: 100%;">
                    </div>
                    <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                        <span>Режим гравитации</span>
                         <div class="radio-group" id="gravity-mode-group">
                            <input type="radio" id="g-realistic" name="gravity" value="realistic" checked><label for="g-realistic">Реалистичный (1/r²)</label>
                            <input type="radio" id="g-linear" name="gravity" value="linear"><label for="g-linear">Линейный (1/r)</label>
                            <input type="radio" id="g-constant" name="gravity" value="constant"><label for="g-constant">Постоянный</label>
                         </div>
                    </div>
                     <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                        <span>Коэффициент орбиты: <span id="decaying-orbit-factor-value">0.80</span></span>
                        <input type="range" id="decaying-orbit-factor-slider" min="0" max="2" step="0.01" value="0.80" style="width: 100%;">
                    </div>
                    <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                        <span>Запас топлива (сек): <span id="fuel-seconds-value">0</span></span>
                        <input type="range" id="fuel-seconds-slider" min="0" max="100" step="1" value="0" style="width: 100%;">
                    </div>
                    <div class="setting-item">
                        <span>Загрязнение обзора</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="poor-visibility-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting-item">
                        <span>Движение облаков пыли</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="dust-clouds-move-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting-item">
                        <span>Показ траектории</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="trajectory-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting-item">
                        <span>Астероиды в цветах уровня</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="level-asteroids-color-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting-item">
                        <span>Лут только в зоне</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="loot-in-zone-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting-item">
                        <span>Интро: планеты из центра</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="intro-planets-center-toggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                     <div class="setting-item">
                        <span>Интро</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="intro-toggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting-item">
                        <span>Игрок сталкивается с астероидами</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="player-collision-toggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                     <div class="setting-item">
                        <span>Столкновения между астероидами</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="asteroid-collision-toggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting-item">
                        <span>Астероиды притягиваются к планетам</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="asteroid-gravity-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                     <div class="setting-item">
                        <span>Лут</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="loot-toggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting-item">
                        <span>Стабилизация</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="stabilization-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
             </div>
             <button class="btn btn-back">Назад</button>
        </div>

        <!-- Модальные окна -->
        <div id="pause-modal" class="modal">
            <div class="modal-content">
                <h2 class="modal-title">Пауза</h2>
                <div class="modal-buttons">
                    <button id="resume-btn" class="btn">Продолжить</button>
                    <button id="quit-to-menu-btn" class="btn">В меню</button>
                </div>
            </div>
        </div>
        
        <div id="game-over-modal" class="modal">
            <div class="modal-content">
                <h2 class="modal-title">Крушение</h2>
                <div id="final-score">Время: <span>0.00</span></div>
                <div id="final-best">Рекорд: <span>0.00</span></div>
                <div id="final-loot" style="display: none;">Собрано: <span>0</span></div>
                <div class="modal-buttons">
                    <button id="restart-btn" class="btn">Заново</button>
                    <button id="menu-btn-gameover" class="btn">В меню</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const gameWrapper = document.querySelector('.game-wrapper');
            const fuelBarContainer = document.getElementById('fuel-bar-container');
            const scoreDisplay = document.getElementById('score-display');
            const pauseBtn = document.getElementById('pause-btn');

            const rocketColor = '#F0F0F0';

            const screens = {
                mainMenu: document.getElementById('main-menu'),
                levelSelect: document.getElementById('level-select-screen'),
                game: document.getElementById('game-screen'),
                stats: document.getElementById('stats-screen'),
                rules: document.getElementById('rules-screen'),
                settings: document.getElementById('settings-screen'),
                devSettings: document.getElementById('dev-settings-screen'),
            };
            const modals = {
                pause: document.getElementById('pause-modal'),
                gameOver: document.getElementById('game-over-modal'),
            };
            
            let gameState = 'menu';
            let pausedState = null;
            let gameTime = 0;
            let animationFrameId;
            let isThrusting = false;
            let particles = [], asteroids = [], debris = [], lootDrops = [], fuelBubbles = [], dustClouds = [], trajectoryPoints = [];
            let fuelShakeIntensity = 0;
            let lootCollected = 0;
            let stabilizationEffect = 0;
            let bgColorRgb = { r: 13, g: 15, b: 26 };
            let fogColorRgb = { r: 13, g: 15, b: 26 };
            let actualTotalPollution = 0, displayedPollution = 0, lingeringPollution = 0;
            
            let stats, settings, devSettings;

            const getDefaultStats = () => ({ bestTime: 0, attempts: 0, unlockedLevel: 99 });
            const getDefaultSettings = () => ({ musicOn: true, soundOn: true });
            const getDefaultDevSettings = () => ({
                controlMode: 'mode2',
                gravityMode: 'linear',
                playerAsteroidCollision: true,
                asteroidAsteroidCollision: true,
                asteroidsHaveGravity: true,
                fuelSeconds: 10,
                enablePollution: true,
                dustCloudsMove: true,
                playIntro: true,
                enableLoot: true,
                asteroidSpeedMultiplier: 0.3,
                colorAsteroidsByLevel: true,
                lootOnlyInZone: true,
                introPlanetsFromCenter: true,
                decayingOrbitFactor: 1.0,
                enableStabilization: true,
                mode2ThrustMultiplier: 0.3,
                asteroidAmountMultiplier: 2.0,
                enableTrajectory: true,
                speedRegulator: 0.8, 
            });


            let lastTapTime = 0;
            let lastTapPos = null;
            const DOUBLE_TAP_DELAY = 300; // Увеличено для более надежного срабатывания
            const PIXELS_PER_CM = 37.8;
            const MAX_DOUBLE_TAP_DISTANCE = PIXELS_PER_CM * 1.5; // Увеличено

            let isDoubleTapHold = false;
            let touchStartPos = null, touchCurrentPos = null, isDragging = false;

            const WORLD_WIDTH = 1000;
            let WORLD_HEIGHT;
            let scaleFactor;
            let isTransitioning = false;
            
            let introTimer = 0;
            const INTRO_DURATION = 4.5;
            const SHIP_ANIM_START = 1.0;
            const OUTLINE_ANIM_START = 3.0;

            const gravityMult = 150 * 30;
            const G_REALISTIC = 8000 * gravityMult;
            const G_LINEAR = 1200 * Math.sqrt(gravityMult);
            const G_CONSTANT = 1.0 * gravityMult;
            const THRUST_FORCE = 600;
            const OUT_OF_BOUNDS_RADIUS_FACTOR = 2.8 * 1.6;
            const ROCKET_SPIN_SPEED = 2 * Math.PI;
            const ASTEROID_SPAWN_RATE = 1.5;
            let lastAsteroidSpawn = 0;
            const STABILIZATION_SPEED_THRESHOLD = 5.0;
            const STABILIZATION_RADIAL_THRESHOLD = 2.0;
            const POLLUTION_DECAY_RATE = 0.25;
            
            let lastTrajectoryPointSpawn = 0;
            const TRAJECTORY_SPAWN_INTERVAL = 1 / 5; 
            const TRAJECTORY_POINT_LIFETIME = 1.0; 
            
            let devicePixelRatio = window.devicePixelRatio || 1;
            
            let planets = [], rocket = {};
            let currentLevel;

            let currentAppliedThrustX = 0, currentAppliedThrustY = 0;
            let visualThrustMagnitude = 0;
            
            const lootTypes = {
                small: { radius: 16, magneticRadius: 120, color: '#FFD700', value: 1 },
                medium: { radius: 24, magneticRadius: 160, color: '#FFA500', value: 3 },
                large: { radius: 32, magneticRadius: 200, color: '#FF4500', value: 5 }
            };

            const levels = [
                {
                    id: 1,
                    globalPollution: 0,
                    theme: {
                        backgroundColor: '#0D0F1A',
                        fogColor: '#08090F',
                        buttonColor: '#4A4E69',
                        outlineColor: 'rgba(0, 162, 255, 0.2)',
                        asteroidColor: '#525f7f',
                        gravityWellColor: 'rgba(80, 100, 150, 0.0175)'
                    },
                    planetConfigs: [ { x: 0.5, y: 0.5, radiusFactor: 0.1, gravityFactor: 1.0, color: '#4A4E69' } ],
                    asteroidSpawnSectors: [ { start: -160, end: -20 }, { start: 110, end: 250 } ]
                },
                {
                    id: 2,
                    globalPollution: 0,
                    theme: {
                        backgroundColor: '#0D1A0F',
                        fogColor: '#080F09',
                        buttonColor: '#3A593E',
                        outlineColor: 'rgba(144, 238, 144, 0.3)',
                        asteroidColor: '#586454',
                        gravityWellColor: 'rgba(144, 238, 144, 0.0125)'
                    },
                    planetConfigs: [
                        { x: 0.5, y: 0.40, radiusFactor: 0.1, gravityFactor: 1.0, color: '#4A694E' },
                        { x: 0.4, y: 1.0, radiusFactor: 0.075, gravityFactor: 0.75, color: '#3A593E' }
                    ],
                    asteroidSpawnSectors: [ { start: -170, end: 10 }, { start: 100, end: 170 } ]
                },
                {
                    id: 3,
                    globalPollution: 0.4,
                    theme: {
                        backgroundColor: '#1A0D1A',
                        fogColor: '#0F080F',
                        buttonColor: '#4E3A59',
                        outlineColor: 'rgba(221, 160, 221, 0.3)',
                        asteroidColor: '#645464',
                        gravityWellColor: 'rgba(221, 160, 221, 0.0125)'
                    },
                    planetConfigs: [ { x: 0.5, y: 0.5, radiusFactor: 0.1, gravityFactor: 1.0, color: '#4E3A59' } ],
                    asteroidSpawnSectors: [ { start: -160, end: -20 }, { start: 110, end: 250 } ]
                },
                {
                    id: 4,
                    globalPollution: 1.0,
                    theme: {
                        backgroundColor: '#1A120D',
                        fogColor: '#0F0B08',
                        buttonColor: '#59423A',
                        outlineColor: 'rgba(255, 140, 0, 0.3)',
                        asteroidColor: '#645A54',
                        gravityWellColor: 'rgba(255, 140, 0, 0.0125)'
                    },
                    planetConfigs: [ { x: 0.5, y: 0.5, radiusFactor: 0.1, gravityFactor: 1.0, color: '#59423A' } ],
                    asteroidSpawnSectors: [ { start: -160, end: -20 }, { start: 110, end: 250 } ]
                }
            ];

            const lerp = (a, b, t) => a * (1 - t) + b * t;
            const rand = (min, max) => Math.random() * (max - min) + min;
            const distance = (p1, p2) => Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
            const animProgress = (startTime, duration) => gameState === 'intro' ? Math.min(1, Math.max(0, introTimer - startTime) / duration) : 1;
            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
            }

            function getFuelColor(ratio) {
                const hue = ratio * 60;
                return `hsl(${hue}, 100%, 50%)`;
            }
            
            function calculateGravityForce(dist, planet) {
                if (dist <= 0) return 0;
                const distSq = dist * dist;
                const speedFactor = devSettings.speedRegulator * devSettings.speedRegulator;
                switch(devSettings.gravityMode) {
                    case 'realistic': return (G_REALISTIC / (distSq + 10000)) * planet.gravityFactor * speedFactor; 
                    case 'linear': return (G_LINEAR / dist) * planet.gravityFactor * speedFactor; 
                    case 'constant': return G_CONSTANT * planet.gravityFactor * speedFactor; 
                }
                return 0;
            }

            function switchScreen(screenName) {
                Object.values(screens).forEach(s => s.classList.remove('active'));
                if (screens[screenName]) screens[screenName].classList.add('active');
            }
            function showModal(modalName) { if (modals[modalName]) modals[modalName].classList.add('active'); }
            function hideModals() { Object.values(modals).forEach(m => m.classList.remove('active')); }

            function setupGameObjects() {
                planets = currentLevel.planetConfigs.map(p => ({
                    x: WORLD_WIDTH * p.x,
                    y: (WORLD_HEIGHT / 2) + (p.y - 0.5) * WORLD_WIDTH,
                    radius: WORLD_WIDTH * p.radiusFactor,
                    gravityFactor: p.gravityFactor,
                    color: p.color
                }));
                
                const primaryPlanet = planets[0];
                const spawnDistance = primaryPlanet.radius + (primaryPlanet.radius * OUT_OF_BOUNDS_RADIUS_FACTOR - primaryPlanet.radius) * 0.5;
                
                const gravityForceAtSpawn = calculateGravityForce(spawnDistance, primaryPlanet);
                const stableOrbitalSpeed = Math.sqrt(gravityForceAtSpawn * spawnDistance);
                const orbitalSpeed = stableOrbitalSpeed * devSettings.decayingOrbitFactor;
                
                const spawnAngle = Math.random() * Math.PI * 2;
                
                const rocketRadius = 15;
                rocket = {
                    x: 0, y: 0, vx: 0, vy: 0, radius: rocketRadius,
                    collisionRadius: rocketRadius * 0.8, angle: 0, isDestroyed: false, 
                    isSpinning: false, fuel: 1, maxFuel: 1,
                };

                const targetX = primaryPlanet.x + Math.cos(spawnAngle) * spawnDistance;
                const targetY = primaryPlanet.y + Math.sin(spawnAngle) * spawnDistance;
                const targetVx = -Math.sin(spawnAngle) * orbitalSpeed;
                const targetVy = Math.cos(spawnAngle) * orbitalSpeed;

                rocket.target = { x: targetX, y: targetY, vx: targetVx, vy: targetVy };

                if (devSettings.playIntro) {
                    const p2 = { x: targetX, y: targetY }; const targetVel = { x: targetVx, y: targetVy };
                    const p0_left = { x: -100, y: WORLD_HEIGHT / 2 }; const p0_right = { x: WORLD_WIDTH + 100, y: WORLD_HEIGHT / 2 };
                    const getControlPoint = (p0, p2_v, targetVel_v) => {
                        const dist = distance(p0, p2_v); const tangent = { x: -targetVel_v.x, y: -targetVel_v.y };
                        const mag = Math.sqrt(tangent.x**2 + tangent.y**2) || 1;
                        return { x: p2_v.x + (tangent.x / mag) * dist * 0.8, y: p2_v.y + (tangent.y / mag) * dist * 0.8 };
                    };
                    const p1_left = getControlPoint(p0_left, p2, targetVel); const p1_right = getControlPoint(p0_right, p2, targetVel);
                    const endTangentLeft = { x: p2.x - p1_left.x, y: p2.y - p1_left.y }; const endTangentRight = { x: p2.x - p1_right.x, y: p2.y - p1_right.y };
                    const magTarget = Math.sqrt(targetVel.x**2 + targetVel.y**2) || 1; const magLeft = Math.sqrt(endTangentLeft.x**2 + endTangentLeft.y**2) || 1;
                    const magRight = Math.sqrt(endTangentRight.x**2 + endTangentRight.y**2) || 1;
                    const dotLeft = (endTangentLeft.x * targetVel.x + endTangentLeft.y * targetVel.y) / (magLeft * magTarget);
                    const dotRight = (endTangentRight.x * targetVel.x + endTangentRight.y * targetVel.y) / (magRight * magTarget);
                    const startPoint = dotLeft > dotRight ? p0_left : p0_right; const controlPoint = dotLeft > dotRight ? p1_left : p1_right;
                    rocket.x = startPoint.x; rocket.y = startPoint.y;
                    rocket.introPath = { p0: startPoint, p1: controlPoint, p2: p2 };
                    gameState = 'intro'; introTimer = 0;
                } else {
                    rocket.x = targetX; rocket.y = targetY;
                    rocket.vx = targetVx; rocket.vy = targetVy;
                    gameState = 'playing';
                }
            }
            
            function loadData() {
                try {
                    const savedStats = localStorage.getItem('orbitalGuardianStats');
                    stats = savedStats ? { ...getDefaultStats(), ...JSON.parse(savedStats) } : getDefaultStats();
                    
                    const savedSettings = localStorage.getItem('orbitalGuardianSettings');
                    settings = savedSettings ? { ...getDefaultSettings(), ...JSON.parse(savedSettings) } : getDefaultSettings();

                    const savedDevSettings = localStorage.getItem('orbitalGuardianDevSettings');
                    devSettings = savedDevSettings ? { ...getDefaultDevSettings(), ...JSON.parse(savedDevSettings) } : getDefaultDevSettings();
                } catch(e) { 
                    console.error("Ошибка загрузки данных, сброс к значениям по умолчанию.", e); 
                    stats = getDefaultStats();
                    settings = getDefaultSettings();
                    devSettings = getDefaultDevSettings();
                }
                updateUI();
            }

            function saveData(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); } catch(e) { console.error("Ошибка сохранения данных", e); } }
            
            function updateUI() {
                document.getElementById('best-time-stat').textContent = stats.bestTime.toFixed(2);
                document.getElementById('attempts-stat').textContent = stats.attempts;
                document.getElementById('music-toggle').checked = settings.musicOn;
                document.getElementById('sound-toggle').checked = settings.soundOn;
                
                document.querySelector(`input[name="controlMode"][value="${devSettings.controlMode}"]`).checked = true;
                document.querySelector(`input[name="gravity"][value="${devSettings.gravityMode}"]`).checked = true;
                document.getElementById('stabilization-toggle').checked = devSettings.enableStabilization;
                document.getElementById('player-collision-toggle').checked = devSettings.playerAsteroidCollision;
                document.getElementById('asteroid-collision-toggle').checked = devSettings.asteroidAsteroidCollision;
                document.getElementById('asteroid-gravity-toggle').checked = devSettings.asteroidsHaveGravity;
                document.getElementById('intro-toggle').checked = devSettings.playIntro;
                document.getElementById('loot-toggle').checked = devSettings.enableLoot;
                document.getElementById('level-asteroids-color-toggle').checked = devSettings.colorAsteroidsByLevel;
                document.getElementById('loot-in-zone-toggle').checked = devSettings.lootOnlyInZone;
                document.getElementById('intro-planets-center-toggle').checked = devSettings.introPlanetsFromCenter;
                
                document.getElementById('fuel-seconds-slider').value = devSettings.fuelSeconds;
                document.getElementById('fuel-seconds-value').textContent = devSettings.fuelSeconds;
                document.getElementById('poor-visibility-toggle').checked = devSettings.enablePollution;
                document.getElementById('dust-clouds-move-toggle').checked = devSettings.dustCloudsMove;
                
                document.getElementById('decaying-orbit-factor-slider').value = devSettings.decayingOrbitFactor;
                document.getElementById('decaying-orbit-factor-value').textContent = devSettings.decayingOrbitFactor.toFixed(2);
                
                document.getElementById('mode2-thrust-slider').value = devSettings.mode2ThrustMultiplier;
                document.getElementById('mode2-thrust-value').textContent = `${Math.round(devSettings.mode2ThrustMultiplier * 100)}%`;
                
                document.getElementById('asteroid-amount-slider').value = devSettings.asteroidAmountMultiplier;
                document.getElementById('asteroid-amount-value').textContent = `${Math.round(devSettings.asteroidAmountMultiplier * 100)}%`;
                
                document.getElementById('trajectory-toggle').checked = devSettings.enableTrajectory;
                
                document.getElementById('speed-regulator-slider').value = devSettings.speedRegulator;
                document.getElementById('speed-regulator-value').textContent = `${Math.round(devSettings.speedRegulator * 100)}%`;
            }
            
            function populateLevelGrid() {
                const grid = document.getElementById('level-grid');
                grid.innerHTML = '';
                const totalSlots = 20;
                for (let i = 1; i <= totalSlots; i++) {
                    const levelData = levels.find(l => l.id === i);
                    const btn = document.createElement('button');
                    btn.classList.add('level-btn');
                    if (levelData) {
                        btn.dataset.level = levelData.id; btn.textContent = levelData.id;
                        btn.style.backgroundColor = levelData.theme.buttonColor;
                        if (levelData.id > stats.unlockedLevel) { btn.classList.add('locked'); btn.disabled = true; }
                    } else { btn.style.visibility = 'hidden'; btn.disabled = true; }
                    grid.appendChild(btn);
                }
            }

            function init() {
                loadData(); populateLevelGrid(); setupEventListeners();
                switchScreen('mainMenu'); resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }
            
            function startGame(levelId) {
                if (isTransitioning) return;
                isTransitioning = true;
                
                scoreDisplay.style.opacity = 0; pauseBtn.style.opacity = 0; fuelBarContainer.style.opacity = 0;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                currentLevel = levels.find(l => l.id === levelId);
                if (!currentLevel) { isTransitioning = false; return; }

                hideModals();
                gameWrapper.style.backgroundColor = currentLevel.theme.backgroundColor;
                bgColorRgb = hexToRgb(currentLevel.theme.backgroundColor) || { r: 13, g: 15, b: 26 };
                fogColorRgb = hexToRgb(currentLevel.theme.fogColor) || { r: 0, g: 0, b: 0 };
                
                setupGameObjects();
                
                gameTime = 0; lastAsteroidSpawn = 0; fuelShakeIntensity = 0; lootCollected = 0; stabilizationEffect = 0;
                lastTrajectoryPointSpawn = 0;
                asteroids = []; particles = []; debris = []; lootDrops = []; fuelBubbles = []; dustClouds = []; trajectoryPoints = [];
                actualTotalPollution = currentLevel.globalPollution || 0;
                displayedPollution = actualTotalPollution;
                lingeringPollution = 0;
                
                stats.attempts++; saveData('orbitalGuardianStats', stats); updateUI();
                document.getElementById('score-display').textContent = "0.00";
                
                if (devSettings.fuelSeconds > 0) {
                    rocket.maxFuel = devSettings.fuelSeconds;
                    rocket.fuel = devSettings.fuelSeconds;
                    fuelBarContainer.style.display = 'block';
                    const fuelBar = document.getElementById('fuel-bar');
                    fuelBar.style.width = '100%';
                    fuelBar.style.backgroundColor = getFuelColor(1);
                } else {
                    rocket.maxFuel = 1; rocket.fuel = 1;
                    fuelBarContainer.style.display = 'none';
                }

                document.getElementById('final-loot').style.display = devSettings.enableLoot ? 'block' : 'none';
                
                switchScreen('game');

                setTimeout(() => {
                    isTransitioning = false;
                    lastTime = performance.now(); 
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = requestAnimationFrame(gameLoop);
                }, 500);
            }

            function endGame(reason) {
                if (gameState === 'gameover') return;
                gameState = 'gameover';
                currentAppliedThrustX = 0;
                currentAppliedThrustY = 0;
                visualThrustMagnitude = 0;
                
                if (reason === 'collision') { rocket.isDestroyed = true; if (settings.soundOn) createExplosion(rocket.x, rocket.y, 100, '#FF4141', 1.0); } 
                else if (reason === 'bounds') { rocket.isSpinning = true; }
                
                if (gameTime > stats.bestTime) { stats.bestTime = gameTime; saveData('orbitalGuardianStats', stats); }
                updateUI();
                document.querySelector('#final-score span').textContent = gameTime.toFixed(2);
                document.querySelector('#final-best span').textContent = stats.bestTime.toFixed(2);
                if (devSettings.enableLoot) document.querySelector('#final-loot span').textContent = lootCollected;
                setTimeout(() => showModal('gameOver'), 1500);
            }
            
            function createExplosion(x, y, count, color, life) {
                 for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2; 
                    const speed = (Math.random() * 150 + 50) * devSettings.speedRegulator;
                    particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                        radius: rand(2, 8), life: Math.random() * life + 0.2, initialLife: life + 0.2, color
                    });
                }
            }
            function createDebris(x, y, count) {
                for (let i = 0; i < count; i++) {
                    debris.push({ x, y, vx: rand(-50, 50) * devSettings.speedRegulator, vy: rand(-50, 50) * devSettings.speedRegulator, radius: rand(4, 10),
                        life: rand(0.5, 1.5), angle: rand(0, Math.PI*2), spin: rand(-Math.PI, Math.PI) });
                }
            }

            function createDustCloud(x, y, initialRadius) {
                const createPoints = () => {
                    const points = []; const anim = []; const offsets = [];
                    const pointCount = Math.round(rand(8, 12));
                    for (let j = 0; j < pointCount; j++) {
                        const angle = (j / pointCount) * Math.PI * 2;
                        const dist = rand(initialRadius * 0.5, initialRadius);
                        points.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist });
                        offsets.push({ x: 0, y: 0 }); 
                        anim.push({
                            phase: rand(0, Math.PI * 2),
                            speed: rand(Math.PI * 0.5, Math.PI * 1.5),
                            maxOffset: rand(initialRadius * 0.1, initialRadius * 0.3)
                        });
                    }
                    return { points, anim, offsets };
                };

                const layer1 = createPoints();
                const layer2 = createPoints();

                dustClouds.push({
                    x, y, vx: 0, vy: 0, radius: initialRadius, life: 10, initialLife: 10, age: 0,
                    angle: rand(0, Math.PI * 2), spin: rand(-Math.PI * 0.3, Math.PI * 0.3),
                    points1: layer1.points, anim1: layer1.anim, offsets1: layer1.offsets,
                    points2: layer2.points, anim2: layer2.anim, offsets2: layer2.offsets,
                    pollutionAmount: 1.0,
                });
            }

            function isInsidePlayArea(x, y) {
                if (!planets || planets.length === 0) return false;
                return planets.some(p => distance({x,y}, p) < p.radius * OUT_OF_BOUNDS_RADIUS_FACTOR);
            }
            
            function spawnLoot(x, y) {
                if (devSettings.lootOnlyInZone && !isInsidePlayArea(x, y)) return;
                const chance = Math.random();
                let type = chance < 0.6 ? lootTypes.small : (chance < 0.9 ? lootTypes.medium : lootTypes.large);
                lootDrops.push({ x, y, vx: rand(-30, 30) * devSettings.speedRegulator, vy: rand(-30, 30) * devSettings.speedRegulator, ...type, age: 0, life: 30 });
            }
            
            function updatePlayingState(dt) {
                gameTime += dt;
                
                currentAppliedThrustX = 0;
                currentAppliedThrustY = 0;
                visualThrustMagnitude = 0;
                
                if (devSettings.enableTrajectory && gameTime - lastTrajectoryPointSpawn > TRAJECTORY_SPAWN_INTERVAL) {
                    trajectoryPoints.push({
                        x: rocket.x, y: rocket.y,
                        life: TRAJECTORY_POINT_LIFETIME, initialLife: TRAJECTORY_POINT_LIFETIME
                    });
                    lastTrajectoryPointSpawn = gameTime;
                }

                lootDrops.forEach((l, index) => {
                    const distToRocket = distance(rocket, l);
                    if (distToRocket < rocket.collisionRadius + l.radius) { lootCollected += l.value; lootDrops.splice(index, 1); return; }
                    if (distToRocket < l.magneticRadius) {
                        const pullSpeed = 400 * devSettings.speedRegulator;
                        l.vx += (rocket.x - l.x) / distToRocket * pullSpeed * dt;
                        l.vy += (rocket.y - l.y) / distToRocket * pullSpeed * dt;
                    }
                    l.vx *= 0.98; l.vy *= 0.98; l.x += l.vx * dt; l.y += l.vy * dt;
                });

                let totalGravityX = 0, totalGravityY = 0, isInsideAnyZone_flag = false;
                let dominantPlanet = null; let maxGravityInfluence = -1;

                planets.forEach(p => {
                    const dx = p.x - rocket.x, dy = p.y - rocket.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < p.radius * OUT_OF_BOUNDS_RADIUS_FACTOR) {
                        isInsideAnyZone_flag = true; const force = calculateGravityForce(dist, p);
                        if (dist > 0) { totalGravityX += (force * dx / dist); totalGravityY += (force * dy / dist); }
                        const influence = force / dist;
                        if (influence > maxGravityInfluence) { maxGravityInfluence = influence; dominantPlanet = p; }
                    }
                });

                if (devSettings.asteroidsHaveGravity) {
                    asteroids.forEach(a => {
                        let asteroidGravityX = 0, asteroidGravityY = 0;
                        planets.forEach(p => {
                             if (isInsidePlayArea(a.x, a.y)) {
                                const dx = p.x - a.x, dy = p.y - a.y; const dist = Math.sqrt(dx*dx + dy*dy);
                                if (dist > 0) {
                                    const force = calculateGravityForce(dist, p) * devSettings.asteroidSpeedMultiplier; 
                                    asteroidGravityX += (force * dx/dist); asteroidGravityY += (force * dy/dist);
                                }
                             }
                        });
                        a.vx += asteroidGravityX * dt; a.vy += asteroidGravityY * dt;
                    });
                }
                
                let totalForceX = totalGravityX, totalForceY = totalGravityY;
                let appliedThrustX = 0, appliedThrustY = 0;
                
                if (isThrusting && (devSettings.fuelSeconds <= 0 || rocket.fuel > 0)) {
                    const currentThrustForce = THRUST_FORCE * devSettings.speedRegulator * devSettings.speedRegulator;
                    const isStabilizing = devSettings.enableStabilization && isDoubleTapHold;

                    if (isStabilizing && dominantPlanet) {
                        const dx = dominantPlanet.x - rocket.x;
                        const dy = dominantPlanet.y - rocket.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        let vCorrectionX = 0, vCorrectionY = 0, hCorrectionX = 0, hCorrectionY = 0;

                        if (dist > 0) {
                            const radialX = dx / dist; const radialY = dy / dist;
                            const radialVelocity = rocket.vx * radialX + rocket.vy * radialY;
                            if (Math.abs(radialVelocity) > STABILIZATION_RADIAL_THRESHOLD * devSettings.speedRegulator) {
                                const verticalCorrectionForce = -radialVelocity * 80;
                                vCorrectionX = radialX * verticalCorrectionForce;
                                vCorrectionY = radialY * verticalCorrectionForce;
                            }
                            
                            const gravityAtDist = calculateGravityForce(dist, dominantPlanet);
                            const stableSpeed = Math.sqrt(gravityAtDist * dist);
                            const tangentX = -dy / dist; const tangentY = dx / dist;
                            const currentTangentialSpeed = rocket.vx * tangentX + rocket.vy * tangentY;
                            const orbitDirection = Math.sign(currentTangentialSpeed) || 1;
                            const targetTangentialSpeed = stableSpeed * orbitDirection;
                            const speedDiff = targetTangentialSpeed - currentTangentialSpeed;

                            if (Math.abs(speedDiff) > STABILIZATION_SPEED_THRESHOLD * devSettings.speedRegulator) {
                                const horizontalCorrectionForce = speedDiff * 60;
                                hCorrectionX = tangentX * horizontalCorrectionForce;
                                hCorrectionY = tangentY * horizontalCorrectionForce;
                            }
                        }

                        const requiredCorrectionX = vCorrectionX + hCorrectionX;
                        const requiredCorrectionY = vCorrectionY + hCorrectionY;
                        const requiredForceMagnitude = Math.sqrt(requiredCorrectionX**2 + requiredCorrectionY**2);
                        
                        if (requiredForceMagnitude < currentThrustForce) {
                            appliedThrustX = 0; appliedThrustY = 0;
                            
                            const tangentX = -dy / dist; const tangentY = dx / dist;
                            const gravityAtDist = calculateGravityForce(dist, dominantPlanet);
                            const stableSpeed = Math.sqrt(gravityAtDist * dist);
                            const currentTangentialSpeed = rocket.vx * tangentX + rocket.vy * tangentY;
                            const orbitDirection = Math.sign(currentTangentialSpeed) || 1;
                            const targetTangentialSpeed = stableSpeed * orbitDirection;

                            rocket.vx = tangentX * targetTangentialSpeed;
                            rocket.vy = tangentY * targetTangentialSpeed;
                        } else {
                            const requiredDirX = requiredCorrectionX / requiredForceMagnitude;
                            const requiredDirY = requiredCorrectionY / requiredForceMagnitude;
                            appliedThrustX = requiredDirX * currentThrustForce;
                            appliedThrustY = requiredDirY * currentThrustForce;
                        }
                    }
                    else if (devSettings.controlMode === 'mode1') {
                        const gravityMagnitude = Math.sqrt(totalGravityX**2 + totalGravityY**2);
                        if(gravityMagnitude > 0) {
                            appliedThrustX = -(totalGravityX / gravityMagnitude) * currentThrustForce;
                            appliedThrustY = -(totalGravityY / gravityMagnitude) * currentThrustForce;
                        }
                    } else if (devSettings.controlMode === 'mode2') {
                        if (isDragging && touchStartPos && touchCurrentPos) {
                            const deltaY = touchCurrentPos.y - touchStartPos.y;
                            const maxDragDist = (canvas.getBoundingClientRect().width / devicePixelRatio) * 0.25;
                            const input = Math.max(-1, Math.min(1, -deltaY / maxDragDist));
                            
                            const unscaledThrustMagnitude = Math.abs(input) * THRUST_FORCE;
                            const thrustMagnitude = unscaledThrustMagnitude * devSettings.mode2ThrustMultiplier * devSettings.speedRegulator * devSettings.speedRegulator;
                            const direction = Math.sign(input);

                            visualThrustMagnitude = unscaledThrustMagnitude;

                            const speed = Math.sqrt(rocket.vx**2 + rocket.vy**2);
                            if (speed > 0) {
                                appliedThrustX = (rocket.vx / speed) * thrustMagnitude * direction;
                                appliedThrustY = (rocket.vy / speed) * thrustMagnitude * direction;
                            } else if (direction > 0) {
                                appliedThrustX = Math.cos(rocket.angle - Math.PI / 2) * thrustMagnitude;
                                appliedThrustY = Math.sin(rocket.angle - Math.PI / 2) * thrustMagnitude;
                            }
                        }
                    }
                   
                   if (visualThrustMagnitude === 0) {
                       visualThrustMagnitude = Math.sqrt(appliedThrustX**2 + appliedThrustY**2);
                   }

                   totalForceX += appliedThrustX; totalForceY += appliedThrustY;
                   
                   if (devSettings.fuelSeconds > 0) {
                        const appliedThrustMagnitude = Math.sqrt(appliedThrustX**2 + appliedThrustY**2);
                        const thrustRatio = appliedThrustMagnitude / currentThrustForce;
                        rocket.fuel = Math.max(0, rocket.fuel - (dt * thrustRatio));
                        document.getElementById('fuel-bar').style.width = `${Math.max(0, rocket.fuel / rocket.maxFuel * 100)}%`;
                        
                        if (rocket.fuel > 0 && thrustRatio > 0) {
                            const effectRatio = 0.5 + thrustRatio * 0.5;
                            // ИЗМЕНЕНИЕ 2: Количество пузырей теперь зависит от effectRatio
                            const maxBubbleSpawnChance = 0.9;
                            if (Math.random() < maxBubbleSpawnChance * effectRatio) {
                                fuelBubbles.push({
                                    x: rand(0, 1), y: rand(0.2, 0.8),
                                    vx: 0, vy: rand(-10, -30), 
                                    radius: rand(6 * effectRatio, 12 * effectRatio), 
                                    life: rand(0.4, 0.7), 
                                    color: Math.random() < 0.5 ? '#FFA500' : '#FF4500'
                                });
                            }
                        }
                   }
                }
                
                currentAppliedThrustX = appliedThrustX;
                currentAppliedThrustY = appliedThrustY;

                rocket.vx += totalForceX * dt; rocket.vy += totalForceY * dt;
                
                if (!rocket.isDestroyed) {
                     rocket.x += rocket.vx * dt; rocket.y += rocket.vy * dt;
                     rocket.angle = Math.atan2(rocket.vy, rocket.vx) + Math.PI / 2;
                }
                
                const effectiveSpawnRate = ASTEROID_SPAWN_RATE / devSettings.asteroidAmountMultiplier;
                if (gameTime - lastAsteroidSpawn > effectiveSpawnRate) { 
                    spawnAsteroid(); 
                    lastAsteroidSpawn = gameTime; 
                }
                
                if (!isInsideAnyZone_flag) endGame('bounds');
                planets.forEach(p => { if (distance(rocket, p) < p.radius + rocket.collisionRadius) endGame('collision'); });
                if (devSettings.playerAsteroidCollision) {
                    asteroids.forEach(a => { if (distance(rocket, a) < a.radius + rocket.collisionRadius) endGame('collision'); });
                }
            }

            function update(dt) {
                if (!dt || !currentLevel) return;
                
                const isStabilizing = isThrusting && devSettings.enableStabilization && isDoubleTapHold;
                const transitionSpeed = 5;
                if (isStabilizing) { stabilizationEffect = Math.min(1, stabilizationEffect + dt * transitionSpeed); } 
                else { stabilizationEffect = Math.max(0, stabilizationEffect - dt * transitionSpeed); }

                if (devSettings.fuelSeconds > 0) {
                    const fuelBar = document.getElementById('fuel-bar');
                    const fuelRatio = rocket.fuel / rocket.maxFuel;
                    if (stabilizationEffect > 0) {
                        const normalHue = fuelRatio * 60;
                        const finalLightness = 50 + (50 * stabilizationEffect);
                        const finalSaturation = 100 - (100 * stabilizationEffect);
                        fuelBar.style.backgroundColor = `hsl(${normalHue}, ${finalSaturation}%, ${finalLightness}%)`;
                    } else { fuelBar.style.backgroundColor = getFuelColor(fuelRatio); }
                }

                particles.forEach(p => { p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt; });
                particles = particles.filter(p => p.life > 0);
                debris.forEach(d => {d.life -= dt; d.x += d.vx * dt; d.y += d.vy * dt; }); 
                debris = debris.filter(d => d.life > 0);
                lootDrops.forEach(l => { l.life -= dt; l.age += dt; }); 
                lootDrops = lootDrops.filter(l => l.life > 0);
                
                fuelBubbles.forEach(b => { b.life -= dt; b.x += b.vx * dt; b.y += b.vy * dt; });
                fuelBubbles = fuelBubbles.filter(b => b.life > 0);
                
                if (devSettings.enableTrajectory) {
                    trajectoryPoints.forEach(p => p.life -= dt);
                    trajectoryPoints = trajectoryPoints.filter(p => p.life > 0);
                }

                dustClouds.forEach((cloud, index) => {
                    cloud.age += dt;
                    cloud.life -= dt;
                    if (cloud.life <= 0) { dustClouds.splice(index, 1); return; }
                    cloud.angle += cloud.spin * dt;
                    
                    cloud.anim1.forEach((anim, i) => {
                        const point = cloud.points1[i];
                        const originalAngle = Math.atan2(point.y, point.x);
                        const offsetMag = Math.sin(cloud.age * anim.speed + anim.phase) * anim.maxOffset;
                        cloud.offsets1[i].x = -Math.sin(originalAngle) * offsetMag;
                        cloud.offsets1[i].y = Math.cos(originalAngle) * offsetMag;
                    });
                    cloud.anim2.forEach((anim, i) => {
                        const point = cloud.points2[i];
                        const originalAngle = Math.atan2(point.y, point.x);
                        const offsetMag = Math.sin(cloud.age * anim.speed + anim.phase) * anim.maxOffset;
                        cloud.offsets2[i].x = -Math.sin(originalAngle) * offsetMag;
                        cloud.offsets2[i].y = Math.cos(originalAngle) * offsetMag;
                    });

                    if (devSettings.dustCloudsMove) {
                        const dx = cloud.x - WORLD_WIDTH / 2; const dy = cloud.y - WORLD_HEIGHT / 2;
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        cloud.vx += (dx / dist) * 15 * dt * devSettings.speedRegulator; 
                        cloud.vy += (dy / dist) * 15 * dt * devSettings.speedRegulator;
                        cloud.vx *= 0.99; cloud.vy *= 0.99;
                        cloud.x += cloud.vx * dt; cloud.y += cloud.vy * dt;
                    }
                });
                
                let cloudPollution = 0;
                if (devSettings.enablePollution) {
                    dustClouds.forEach(cloud => {
                        const progress = 1 - (cloud.life / cloud.initialLife);
                        const currentRadius = cloud.radius * (1 + progress * 2);

                        if (distance(rocket, cloud) < currentRadius) {
                            let pollutionFactor;
                            if (progress < 0.8) {
                                pollutionFactor = 1.0 - (progress / 0.8) * 0.5;
                            } else {
                                const t_sub = (progress - 0.8) / 0.2;
                                pollutionFactor = 0.5 - t_sub * 0.5;
                            }
                            cloudPollution += cloud.pollutionAmount * pollutionFactor;
                        }
                    });
                }
                lingeringPollution = Math.max(0, lingeringPollution - POLLUTION_DECAY_RATE * dt);
                let currentLocalPollution = Math.max(cloudPollution, lingeringPollution);
                lingeringPollution = currentLocalPollution;

                actualTotalPollution = Math.min(1, (currentLevel.globalPollution || 0) + currentLocalPollution);
                displayedPollution = lerp(displayedPollution, actualTotalPollution, dt * 3.0);

                asteroids.forEach((a, index) => {
                    a.x += a.vx * dt; a.y += a.vy * dt; a.angle += a.spin * dt;
                    let removed = false;
                    planets.forEach(p => {
                        if (!removed && distance(a, p) < p.radius + a.radius) {
                            if (settings.soundOn) createDebris(a.x, a.y, 5);
                            if (devSettings.enablePollution) createDustCloud(a.x, a.y, a.radius);
                            if (devSettings.enableLoot && Math.random() < 0.5) spawnLoot(a.x, a.y);
                            asteroids.splice(index, 1); removed = true;
                        }
                    });
                });
                
                if (devSettings.asteroidAsteroidCollision) {
                    for (let i = 0; i < asteroids.length; i++) {
                        for (let j = i + 1; j < asteroids.length; j++) {
                            const a1 = asteroids[i]; const a2 = asteroids[j];
                            if (distance(a1, a2) < a1.radius + a2.radius) {
                                if (settings.soundOn) {
                                    const cx = (a1.x + a2.x)/2, cy = (a1.y + a2.y)/2;
                                    createDebris(cx, cy, 5);
                                    if (devSettings.enablePollution) createDustCloud(cx, cy, (a1.radius + a2.radius) / 2);
                                    if (devSettings.enableLoot && Math.random() < 0.5) spawnLoot(cx, cy);
                                }
                                asteroids.splice(j, 1); asteroids.splice(i, 1); i--; break;
                            }
                        }
                    }
                }
                
                let targetShakeIntensity = 0;
                if (isThrusting && devSettings.fuelSeconds > 0) {
                    const thrustRatio = Math.min(1, visualThrustMagnitude / THRUST_FORCE);
                    if (rocket.fuel <= 0) {
                        targetShakeIntensity = 1.0; 
                    } else if (thrustRatio > 0) {
                        targetShakeIntensity = 0.5 + thrustRatio * 0.5;
                    }
                }
                fuelShakeIntensity = lerp(fuelShakeIntensity, targetShakeIntensity, dt * 10.0);

                if (gameState === 'gameover') {
                    if (rocket.isSpinning) rocket.angle += ROCKET_SPIN_SPEED * dt;
                    rocket.x += rocket.vx * dt; rocket.y += rocket.vy * dt;
                    return; 
                }
                
                if (gameState === 'intro') {
                    // ИЗМЕНЕНИЕ 5: Скорость интро теперь не зависит от регулятора скорости
                    introTimer += dt;
                    const shipAnimDuration = INTRO_DURATION - SHIP_ANIM_START;
                    const t_ship = Math.min(1, Math.max(0, introTimer - SHIP_ANIM_START) / shipAnimDuration);
                    if (t_ship > 0) {
                        const t_ease = t_ship < 0.5 ? 4 * t_ship * t_ship * t_ship : 1 - Math.pow(-2 * t_ship + 2, 3) / 2;
                        const p = rocket.introPath;
                        const prev_x = rocket.x; const prev_y = rocket.y;
                        rocket.x = (1 - t_ease)**2 * p.p0.x + 2 * (1 - t_ease) * t_ease * p.p1.x + t_ease**2 * p.p2.x;
                        rocket.y = (1 - t_ease)**2 * p.p0.y + 2 * (1 - t_ease) * t_ease * p.p1.y + t_ease**2 * p.p2.y;
                        if(t_ship > 0.01 && dt > 0) {
                             rocket.vx = (rocket.x - prev_x) / dt; rocket.vy = (rocket.y - prev_y) / dt;
                             rocket.angle = Math.atan2(rocket.vy, rocket.vx) + Math.PI/2;
                        }
                    }
                    if (introTimer >= INTRO_DURATION) {
                        const overflowDt = introTimer - INTRO_DURATION;
                        rocket.x = rocket.target.x; rocket.y = rocket.target.y;
                        rocket.vx = rocket.target.vx; rocket.vy = rocket.target.vy;
                        rocket.angle = Math.atan2(rocket.vy, rocket.vx) + Math.PI / 2;
                        gameState = 'playing'; gameTime = 0;
                        updatePlayingState(overflowDt);
                    }
                    return;
                }
                
                if (gameState === 'playing') updatePlayingState(dt);
            }

            function spawnAsteroid() {
                const spawnDist = WORLD_WIDTH * 1.2;
                const sectors = currentLevel.asteroidSpawnSectors || [{ start: 0, end: 360 }];
                const sector = sectors[Math.floor(Math.random() * sectors.length)];
                const angleRad = rand(sector.start, sector.end) * (Math.PI / 180);

                const x = WORLD_WIDTH/2 + Math.cos(angleRad) * spawnDist; const y = WORLD_HEIGHT/2 + Math.sin(angleRad) * spawnDist;

                const avgPlanetX = planets.reduce((acc, p) => acc + p.x, 0) / planets.length;
                const avgPlanetY = planets.reduce((acc, p) => acc + p.y, 0) / planets.length;

                const directAngle = Math.atan2(avgPlanetY - y, avgPlanetX - x);
                const tangentFactor = devSettings.asteroidsHaveGravity ? rand(-0.6, 0.6) : rand(-0.05, 0.05);
                const finalAngle = directAngle + (Math.PI / 2) * tangentFactor;
                
                const speed = rand(150, 300) * devSettings.asteroidSpeedMultiplier * devSettings.speedRegulator;
                const radius = rand(15, 35);
                const points = []; const pointCount = Math.round(rand(6, 8));
                for (let j = 0; j < pointCount; j++) {
                    const pAngle = (j / pointCount) * Math.PI * 2;
                    const pDist = rand(radius * 0.8, radius); 
                    points.push({ x: Math.cos(pAngle) * pDist, y: Math.sin(pAngle) * pDist });
                }
                const color = devSettings.colorAsteroidsByLevel ? currentLevel.theme.asteroidColor : getComputedStyle(document.documentElement).getPropertyValue('--asteroid-color-default');
                asteroids.push({ x, y, vx: Math.cos(finalAngle) * speed, vy: Math.sin(finalAngle) * speed, radius, angle: 0, spin: rand(-Math.PI, Math.PI), points, color });
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (gameState === 'intro') {
                    const uiAnimProgress = animProgress(OUTLINE_ANIM_START, INTRO_DURATION - OUTLINE_ANIM_START);
                    if (uiAnimProgress > 0) {
                        const finalAlpha = 0.5 - 0.5 * Math.cos(uiAnimProgress * Math.PI);
                        scoreDisplay.style.opacity = finalAlpha; pauseBtn.style.opacity = finalAlpha; fuelBarContainer.style.opacity = finalAlpha;
                    }
                } else if (gameState === 'playing' || gameState === 'gameover' || gameState === 'paused') {
                    scoreDisplay.style.opacity = 1; pauseBtn.style.opacity = 1; fuelBarContainer.style.opacity = 1;
                } else {
                    scoreDisplay.style.opacity = 0; pauseBtn.style.opacity = 0; fuelBarContainer.style.opacity = 0;
                }

                if (currentLevel) {
                    const t_outline = animProgress(OUTLINE_ANIM_START, INTRO_DURATION - OUTLINE_ANIM_START);
                    const wellAlpha = t_outline > 0 ? (0.5 - 0.5 * Math.cos(t_outline * Math.PI)) * (0.6 + 0.4 * Math.sin(t_outline * Math.PI * 6)) : 0;
                    if(wellAlpha > 0) {
                        ctx.save(); ctx.globalAlpha = wellAlpha; ctx.globalCompositeOperation = 'lighter';
                        planets.forEach(p => {
                            ctx.fillStyle = currentLevel.theme.gravityWellColor || 'rgba(255,255,255,0.05)';
                            ctx.beginPath(); ctx.arc(p.x * scaleFactor, p.y * scaleFactor, p.radius * OUT_OF_BOUNDS_RADIUS_FACTOR * scaleFactor, 0, Math.PI * 2); ctx.fill();
                        });
                        ctx.restore();
                    }
                }

                const t_stars = animProgress(0.2, 1.0);
                const starVisibility = devSettings.enablePollution ? Math.max(0, 1 - displayedPollution * 2) : 1;
                if(t_stars > 0 && starVisibility > 0) {
                    if(!this.stars) {
                        this.stars = [];
                        for(let i = 0; i < 100; i++) this.stars.push({x: rand(0, WORLD_WIDTH), y: rand(0, WORLD_HEIGHT), r: rand(0.5, 1.5), opacity: rand(0.2, 0.8)});
                    }
                    this.stars.forEach(s => { 
                        ctx.fillStyle = `rgba(255, 255, 255, ${s.opacity * t_stars * starVisibility})`;
                        ctx.beginPath(); ctx.arc(s.x * scaleFactor, s.y * scaleFactor, s.r * scaleFactor, 0, Math.PI * 2); ctx.fill(); 
                    });
                }
                
                if (devSettings.enableTrajectory) {
                    trajectoryPoints.forEach(p => {
                        const progress = p.life / p.initialLife;
                        const radius = 3 * progress;
                        const alpha = 0.4 * progress; 
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(p.x * scaleFactor, p.y * scaleFactor, radius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
                
                const t_planets = animProgress(0.7, 1.5);
                if(t_planets > 0) {
                    planets.forEach(p => {
                        ctx.save();
                        const scale = gameState === 'intro' ? (t_planets * t_planets * (3 - 2 * t_planets)) : 1.0;
                        let currentX = p.x; let currentY = p.y;
                        if(gameState === 'intro' && devSettings.introPlanetsFromCenter) {
                            const centerX = WORLD_WIDTH / 2; const centerY = WORLD_HEIGHT / 2;
                            const ease = t_planets < 0.5 ? 2 * t_planets * t_planets : 1 - Math.pow(-2 * t_planets + 2, 2) / 2;
                            currentX = centerX + (p.x - centerX) * ease; currentY = centerY + (p.y - centerY) * ease;
                        }
                        ctx.translate(currentX * scaleFactor, currentY * scaleFactor);
                        ctx.scale(scale, scale);
                        ctx.translate(-currentX * scaleFactor, -currentY * scaleFactor);
                        ctx.fillStyle = p.color; ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 20 * scale;
                        ctx.beginPath(); ctx.arc(currentX * scaleFactor, currentY * scaleFactor, p.radius * scaleFactor, 0, Math.PI * 2); ctx.fill();
                        ctx.restore();
                    });
                }
                
                ctx.globalAlpha = 1.0;
                asteroids.forEach(a => {
                    ctx.save(); ctx.translate(a.x * scaleFactor, a.y * scaleFactor); ctx.rotate(a.angle);
                    ctx.fillStyle = a.color; ctx.beginPath();
                    ctx.moveTo(a.points[0].x * scaleFactor, a.points[0].y * scaleFactor);
                    for (let i = 1; i < a.points.length; i++) ctx.lineTo(a.points[i].x * scaleFactor, a.points[i].y * scaleFactor);
                    ctx.closePath(); ctx.fill(); ctx.restore();
                });

                dustClouds.forEach(cloud => {
                    const progress = 1 - (cloud.life / cloud.initialLife);
                    const currentScale = 1 + progress * 2;
                    const currentAlpha = 0.35 * (1 - progress);
                    
                    ctx.save(); 
                    ctx.translate(cloud.x * scaleFactor, cloud.y * scaleFactor);
                    ctx.rotate(cloud.angle); 
                    ctx.scale(currentScale, currentScale);
                    ctx.fillStyle = `rgba(120, 120, 120, ${currentAlpha})`; 

                    ctx.beginPath();
                    ctx.moveTo(
                        (cloud.points1[0].x + cloud.offsets1[0].x) * scaleFactor, 
                        (cloud.points1[0].y + cloud.offsets1[0].y) * scaleFactor
                    );
                    for (let i = 1; i < cloud.points1.length; i++) {
                        ctx.lineTo(
                            (cloud.points1[i].x + cloud.offsets1[i].x) * scaleFactor, 
                            (cloud.points1[i].y + cloud.offsets1[i].y) * scaleFactor
                        );
                    }
                    ctx.closePath(); 
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(
                        (cloud.points2[0].x + cloud.offsets2[0].x) * scaleFactor, 
                        (cloud.points2[0].y + cloud.offsets2[0].y) * scaleFactor
                    );
                    for (let i = 1; i < cloud.points2.length; i++) {
                        ctx.lineTo(
                            (cloud.points2[i].x + cloud.offsets2[i].x) * scaleFactor, 
                            (cloud.points2[i].y + cloud.offsets2[i].y) * scaleFactor
                        );
                    }
                    ctx.closePath(); 
                    ctx.fill();
                    
                    ctx.restore();
                });

                debris.forEach(d => {
                    ctx.save(); ctx.translate(d.x * scaleFactor, d.y * scaleFactor); ctx.rotate(d.angle);
                    ctx.fillStyle = `rgba(154, 140, 152, ${d.life / 1.5})`;
                    ctx.fillRect(-d.radius * scaleFactor, -d.radius*scaleFactor, d.radius * 2 * scaleFactor, d.radius * 2 * scaleFactor);
                    ctx.restore();
                });
                
                lootDrops.forEach(l => {
                    ctx.save(); ctx.translate(l.x * scaleFactor, l.y * scaleFactor);
                    const spawnScale = Math.min(1, l.age / 0.3);
                    const alpha = l.life < 10 && Math.floor(l.life * 5) % 2 === 0 ? 0.5 : 1.0;
                    ctx.fillStyle = l.color; ctx.globalAlpha = alpha; ctx.shadowColor = l.color; ctx.shadowBlur = 15 * scaleFactor * spawnScale;
                    const size = l.radius * scaleFactor * spawnScale; ctx.fillRect(-size/2, -size/2, size, size);
                    ctx.restore();
                });
                
                particles.forEach(p => {
                    ctx.globalAlpha = p.life / p.initialLife; ctx.fillStyle = p.color;
                    ctx.beginPath();
                    const r = p.radius * scaleFactor;
                    ctx.arc(p.x * scaleFactor, p.y * scaleFactor, r, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                if (!rocket.isDestroyed) {
                    const t_ship_appear = animProgress(SHIP_ANIM_START, 0.5);
                    if(t_ship_appear > 0) {
                         ctx.save();
                         ctx.globalAlpha = t_ship_appear;
                         ctx.translate(rocket.x * scaleFactor, rocket.y * scaleFactor);
                         ctx.rotate(rocket.angle);
                         
                        if (visualThrustMagnitude > 1.0) {
                            const thrustRatio = Math.min(1, visualThrustMagnitude / THRUST_FORCE);
                            
                            const minThrustRatio = 0.2;
                            const displayThrustRatio = minThrustRatio + (1 - minThrustRatio) * thrustRatio;

                            const thrustAngle = Math.atan2(currentAppliedThrustY, currentAppliedThrustX);
                            const shipForwardAngle = rocket.angle - Math.PI / 2;
                            const relativeThrustAngle = thrustAngle - shipForwardAngle;

                            ctx.save();
                            ctx.rotate(relativeThrustAngle); 

                            const baseFlameLength = rocket.radius * 3.5;
                            const baseFlameWidth = rocket.radius * 1.0;
                            const flicker = 1.0 + Math.sin(gameTime * 50) * 0.15;
                            const flameLength = baseFlameLength * displayThrustRatio * flicker;
                            const flameWidth = baseFlameWidth * displayThrustRatio * flicker;
                            
                            const grad = ctx.createLinearGradient(0, rocket.radius * scaleFactor, 0, (rocket.radius + flameLength) * scaleFactor);
                            grad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                            grad.addColorStop(0.6, 'rgba(255, 215, 0, 0.7)');
                            grad.addColorStop(1, 'rgba(255, 69, 0, 0)');

                            ctx.fillStyle = grad;
                            ctx.beginPath();
                            ctx.moveTo(0, rocket.radius * 0.8 * scaleFactor);
                            ctx.lineTo(-flameWidth / 2 * scaleFactor, rocket.radius * 1.2 * scaleFactor);
                            ctx.lineTo(0, (rocket.radius + flameLength) * scaleFactor);
                            ctx.lineTo(flameWidth / 2 * scaleFactor, rocket.radius * 1.2 * scaleFactor);
                            ctx.closePath();
                            ctx.fill();
                            
                            ctx.restore();
                        }

                         ctx.fillStyle = rocketColor; ctx.beginPath();
                         const r = rocket.radius * scaleFactor;
                         ctx.moveTo(0, -r); ctx.lineTo(r * 0.7, r); ctx.lineTo(-r * 0.7, r);
                         ctx.closePath(); ctx.fill();
                         ctx.restore();
                    }
                }
                
                if (devSettings.enablePollution) drawPollutionFog();

                if(currentLevel) drawPlayAreaOutline();

                if (fuelShakeIntensity > 0.01) {
                    const shakeX = (Math.random() - 0.5) * 25 * fuelShakeIntensity;
                    const shakeY = (Math.random() - 0.5) * 25 * fuelShakeIntensity;
                    const shakeRot = (Math.random() - 0.5) * 10 * fuelShakeIntensity;
                    fuelBarContainer.style.transform = `translate(${shakeX}px, ${shakeY}px) rotate(${shakeRot}deg)`;
                } else {
                    fuelBarContainer.style.transform = 'translate(0,0) rotate(0deg)';
                }
                
                if (devSettings.fuelSeconds > 0 && fuelBubbles.length > 0) {
                    const barEl = document.getElementById('fuel-bar');
                    const canvasRect = canvas.getBoundingClientRect();
                    const barRect = barEl.getBoundingClientRect();
                    
                    // ИЗМЕНЕНИЕ 1: Исправлено масштабирование пузырей на экранах с высоким DPI (мобильные).
                    // Убран лишний делитель devicePixelRatio, так как canvas.context уже отмасштабирован.
                    // Теперь координаты в CSS-пикселях напрямую соответствуют координатам отрисовки.
                    const barX = barRect.left - canvasRect.left;
                    const barY = barRect.top - canvasRect.top;
                    const barHeight = barRect.height;
                    const currentFuelWidth = barRect.width;

                    fuelBubbles.forEach(b => {
                        ctx.fillStyle = b.color;
                        ctx.globalAlpha = b.life / 0.7;
                        ctx.beginPath();
                        const bubbleX = barX + currentFuelWidth * b.x + b.vx;
                        const bubbleY = barY + barHeight * b.y + b.vy;
                        ctx.arc(bubbleX, bubbleY, b.radius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1.0;
                }
                
                if (gameState === 'playing') document.getElementById('score-display').textContent = gameTime.toFixed(2);
            }
            
            function drawPollutionFog() {
                if (!currentLevel || displayedPollution <= 0) return;
                
                const maxGradientEndRadius = WORLD_WIDTH * 2;
                const minGradientEndRadius = 300;

                // ИЗМЕНЕНИЕ 3: Переработанный ремаппинг для тумана загрязнения.
                // Теперь кривая эффекта настраивается через массив точек.
                // Можешь легко менять эти значения для достижения нужного эффекта.
                // { disp: уровень загрязнения (0-1), remap: степень закрытия обзора (0-1) }
                const pollutionRemapPoints = [
                    { disp: 0.0,  remap: 0.0 },   // При 0% загрязнения тумана нет
                    { disp: 0.25, remap: 0.7 },  // При 25% загрязнения обзор закрыт на 70%
                    { disp: 0.7,  remap: 0.95 }, // При 70% загрязнения обзор закрыт на 95%
                    { disp: 1.0,  remap: 1.0 }   // При 100% загрязнения обзор закрыт на 100%
                ];

                let remappedPollution = 0;
                if (displayedPollution >= 1.0) {
                    remappedPollution = 1.0;
                } else {
                    for (let i = 1; i < pollutionRemapPoints.length; i++) {
                        if (displayedPollution <= pollutionRemapPoints[i].disp) {
                            const prev = pollutionRemapPoints[i - 1];
                            const curr = pollutionRemapPoints[i];
                            const range = curr.disp - prev.disp;
                            if (range > 0) {
                                const t = (displayedPollution - prev.disp) / range;
                                remappedPollution = lerp(prev.remap, curr.remap, t);
                            } else {
                                remappedPollution = prev.remap;
                            }
                            break; 
                        }
                    }
                }
                
                const currentGradientEndRadius = lerp(maxGradientEndRadius, minGradientEndRadius, remappedPollution);
                
                ctx.save();
                const rocketScreenX = rocket.x * scaleFactor; 
                const rocketScreenY = rocket.y * scaleFactor;
                const gradientEndRadiusScaled = currentGradientEndRadius * scaleFactor;
                
                const gradient = ctx.createRadialGradient(rocketScreenX, rocketScreenY, 0, rocketScreenX, rocketScreenY, gradientEndRadiusScaled);
                
                const fogColor = `rgba(${fogColorRgb.r}, ${fogColorRgb.g}, ${fogColorRgb.b}, ${displayedPollution})`;
                const transparentColor = `rgba(${fogColorRgb.r}, ${fogColorRgb.g}, ${fogColorRgb.b}, 0)`;
                
                gradient.addColorStop(0, transparentColor);
                gradient.addColorStop(1, fogColor);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width / devicePixelRatio, canvas.height / devicePixelRatio);
                ctx.restore();
            }

            function drawPlayAreaOutline() {
                if (!currentLevel || !planets || planets.length === 0) return;
                const t_outline = animProgress(OUTLINE_ANIM_START, INTRO_DURATION - OUTLINE_ANIM_START);
                if (t_outline <= 0) return;
                const baseAlpha = 0.5 - 0.5 * Math.cos(t_outline * Math.PI);
                const blinkMultiplier = 0.6 + 0.4 * Math.sin(t_outline * Math.PI * 6);
                ctx.globalAlpha = baseAlpha * blinkMultiplier;
                ctx.strokeStyle = currentLevel.theme.outlineColor; ctx.lineWidth = 2; ctx.setLineDash([10, 10]);
                ctx.beginPath();
                const zones = planets.map(p => ({ x: p.x * scaleFactor, y: p.y * scaleFactor, radius: p.radius * OUT_OF_BOUNDS_RADIUS_FACTOR * scaleFactor }));
                if (zones.length === 1) { ctx.arc(zones[0].x, zones[0].y, zones[0].radius, 0, Math.PI * 2); } 
                else if (zones.length >= 2) {
                    const p1 = zones[0], p2 = zones[1]; const r1 = p1.radius, r2 = p2.radius;
                    const d = Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);
                    if (d > r1 + r2 || d <= Math.abs(r1 - r2)) { ctx.arc(p1.x, p1.y, r1, 0, Math.PI*2); ctx.moveTo(p2.x+r2, p2.y); ctx.arc(p2.x, p2.y, r2, 0, Math.PI*2); } 
                    else {
                        const a = (d*d + r1*r1 - r2*r2)/(2*d); const h = Math.sqrt(r1*r1 - a*a);
                        const x2 = p1.x+a*(p2.x-p1.x)/d; const y2 = p1.y+a*(p2.y-p1.y)/d;
                        const pt1x = x2+h*(p2.y-p1.y)/d; const pt1y = y2-h*(p2.x-p1.x)/d;
                        const pt2x = x2-h*(p2.y-p1.y)/d; const pt2y = y2+h*(p2.x-p1.x)/d;
                        const a11=Math.atan2(pt1y-p1.y,pt1x-p1.x); const a12=Math.atan2(pt2y-p1.y,pt2x-p1.x);
                        const a21=Math.atan2(pt1y-p2.y,pt1x-p2.x); const a22=Math.atan2(pt2y-p2.y,pt2x-p2.x);
                        ctx.arc(p1.x,p1.y,r1,a12,a11); ctx.arc(p2.x,p2.y,r2,a21,a22);
                    }
                }
                ctx.stroke(); ctx.setLineDash([]); ctx.globalAlpha = 1.0;
            }

            let lastTime = 0;
            function gameLoop(timestamp) {
                if (!lastTime) lastTime = timestamp;
                const deltaTime = (timestamp - lastTime) / 1000;
                lastTime = timestamp;
                if (gameState !== 'paused') update(Math.min(deltaTime, 0.1));
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            function setupEventListeners() {
                const getTouchPos = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches && e.touches.length > 0 ? e.touches[0] : (e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches[0] : e);
                    return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
                };
                
                 // --- ИЗМЕНЕНИЕ 4: Логика двойного клика ---
                const handleStart = (e) => {
                    e.preventDefault();
                    if (gameState !== 'playing' && gameState !== 'intro') return;
                    
                    const now = Date.now();
                    const currentPos = getTouchPos(e);
                    
                    // Проверка на дабл-клик теперь происходит в начале второго нажатия.
                    // Таймер измеряет время между НАЧАЛОМ первого и НАЧАЛОМ второго клика.
                    if (now - lastTapTime < DOUBLE_TAP_DELAY && lastTapPos && distance(currentPos, lastTapPos) < MAX_DOUBLE_TAP_DISTANCE) {
                        isDoubleTapHold = true;
                        // Сбрасываем таймер, чтобы "поглотить" этот дабл-клик и избежать
                        // тройных кликов, которые бы снова активировали режим.
                        lastTapTime = 0; 
                    } else {
                        // Если это не дабл-клик, то это начало потенциально нового дабл-клика.
                        // Запоминаем время и позицию НАЧАЛА этого клика.
                        lastTapTime = now;
                        lastTapPos = currentPos;
                    }

                    if (devSettings.controlMode === 'mode2') {
                        isDragging = true;
                        touchStartPos = currentPos;
                        touchCurrentPos = touchStartPos;
                    }
                    isThrusting = true;
                    if (devSettings.controlMode === 'mode2') {
                        draw();
                    }
                };

                const handleMove = (e) => {
                    if (!isDragging || devSettings.controlMode !== 'mode2') return;
                    e.preventDefault();
                    touchCurrentPos = getTouchPos(e);
                };

                const handleEnd = (e) => {
                    e.preventDefault();
                    isThrusting = false;
                    isDoubleTapHold = false;
                    isDragging = false;
                    touchStartPos = null;
                    touchCurrentPos = null;
                    // Время и позиция теперь сохраняются в handleStart, поэтому здесь ничего не делаем.
                };
                
                canvas.addEventListener('mousedown', handleStart);
                canvas.addEventListener('mousemove', handleMove);
                canvas.addEventListener('mouseup', handleEnd);
                canvas.addEventListener('mouseleave', handleEnd);
                canvas.addEventListener('touchstart', handleStart, { passive: false });
                canvas.addEventListener('touchmove', handleMove, { passive: false });
                canvas.addEventListener('touchend', handleEnd, { passive: false });
                
                document.getElementById('play-btn').addEventListener('click', () => switchScreen('levelSelect'));
                document.getElementById('level-grid').addEventListener('click', (e) => {
                    const levelButton = e.target.closest('.level-btn');
                    if (levelButton && !levelButton.disabled) startGame(parseInt(levelButton.dataset.level, 10));
                });
                
                document.getElementById('restart-btn').addEventListener('click', () => { if (!isTransitioning) { hideModals(); startGame(currentLevel.id); } });
                document.getElementById('menu-btn-gameover').addEventListener('click', () => { if (!isTransitioning) { hideModals(); quitToMenu(); } });
                
                document.getElementById('pause-btn').addEventListener('click', () => {
                    if (gameState === 'playing' || gameState === 'intro') { pausedState = gameState; gameState = 'paused'; showModal('pause'); }
                });
                document.getElementById('resume-btn').addEventListener('click', () => {
                    if (gameState === 'paused') { gameState = pausedState; pausedState = null; hideModals(); lastTime = performance.now(); }
                });

                const quitToMenu = () => {
                     if (isTransitioning) return;
                     hideModals(); gameWrapper.style.backgroundColor = 'var(--primary-bg)';
                     switchScreen('mainMenu'); gameState = 'menu'; currentLevel = null;
                     currentAppliedThrustX = 0;
                     currentAppliedThrustY = 0;
                     visualThrustMagnitude = 0;
                     ctx.clearRect(0,0,canvas.width,canvas.height);
                     if(animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                };
                document.getElementById('quit-to-menu-btn').addEventListener('click', quitToMenu);
                document.querySelectorAll('.btn-back').forEach(btn => btn.addEventListener('click', quitToMenu));

                document.getElementById('rules-btn-menu').addEventListener('click', () => switchScreen('rules'));
                document.getElementById('stats-btn-menu').addEventListener('click', () => switchScreen('stats'));
                document.getElementById('settings-btn-menu').addEventListener('click', () => switchScreen('settings'));
                document.getElementById('dev-settings-btn-menu').addEventListener('click', () => switchScreen('devSettings'));
                
                document.getElementById('reset-settings-btn').addEventListener('click', () => {
                    if (confirm('Вы уверены, что хотите сбросить все настройки и статистику?')) {
                        localStorage.removeItem('orbitalGuardianStats');
                        localStorage.removeItem('orbitalGuardianSettings');
                        localStorage.removeItem('orbitalGuardianDevSettings');
                        location.reload();
                    }
                });

                document.getElementById('music-toggle').addEventListener('change', e => { settings.musicOn = e.target.checked; saveData('orbitalGuardianSettings', settings); });
                document.getElementById('sound-toggle').addEventListener('change', e => { settings.soundOn = e.target.checked; saveData('orbitalGuardianSettings', settings); });
                document.getElementById('control-mode-group').addEventListener('change', e => { if (e.target.name === 'controlMode') { devSettings.controlMode = e.target.value; saveData('orbitalGuardianDevSettings', devSettings); }});
                document.getElementById('gravity-mode-group').addEventListener('change', e => { if (e.target.name === 'gravity') { devSettings.gravityMode = e.target.value; saveData('orbitalGuardianDevSettings', devSettings); }});
                document.getElementById('stabilization-toggle').addEventListener('change', e => { devSettings.enableStabilization = e.target.checked; saveData('orbitalGuardianDevSettings', devSettings); });
                document.getElementById('player-collision-toggle').addEventListener('change', e => { devSettings.playerAsteroidCollision = e.target.checked; saveData('orbitalGuardianDevSettings', devSettings); });
                document.getElementById('asteroid-collision-toggle').addEventListener('change', e => { devSettings.asteroidAsteroidCollision = e.target.checked; saveData('orbitalGuardianDevSettings', devSettings); });
                document.getElementById('asteroid-gravity-toggle').addEventListener('change', e => { devSettings.asteroidsHaveGravity = e.target.checked; saveData('orbitalGuardianDevSettings', devSettings); });
                document.getElementById('intro-toggle').addEventListener('change', e => { devSettings.playIntro = e.target.checked; saveData('orbitalGuardianDevSettings', devSettings); });
                document.getElementById('loot-toggle').addEventListener('change', e => { devSettings.enableLoot = e.target.checked; saveData('orbitalGuardianDevSettings', devSettings); });
                document.getElementById('level-asteroids-color-toggle').addEventListener('change', e => { devSettings.colorAsteroidsByLevel = e.target.checked; saveData('orbitalGuardianDevSettings', devSettings); });
                document.getElementById('loot-in-zone-toggle').addEventListener('change', e => { devSettings.lootOnlyInZone = e.target.checked; saveData('orbitalGuardianDevSettings', devSettings); });
                document.getElementById('intro-planets-center-toggle').addEventListener('change', e => { devSettings.introPlanetsFromCenter = e.target.checked; saveData('orbitalGuardianDevSettings', devSettings); });
                document.getElementById('decaying-orbit-factor-slider').addEventListener('input', e => {
                    const value = parseFloat(e.target.value);
                    devSettings.decayingOrbitFactor = value; document.getElementById('decaying-orbit-factor-value').textContent = value.toFixed(2);
                    saveData('orbitalGuardianDevSettings', devSettings);
                });
                document.getElementById('fuel-seconds-slider').addEventListener('input', e => {
                    const value = parseInt(e.target.value, 10);
                    devSettings.fuelSeconds = value; document.getElementById('fuel-seconds-value').textContent = value;
                    saveData('orbitalGuardianDevSettings', devSettings);
                });
                document.getElementById('poor-visibility-toggle').addEventListener('change', e => { devSettings.enablePollution = e.target.checked; saveData('orbitalGuardianDevSettings', devSettings); });
                document.getElementById('dust-clouds-move-toggle').addEventListener('change', e => { devSettings.dustCloudsMove = e.target.checked; saveData('orbitalGuardianDevSettings', devSettings); });
                document.getElementById('trajectory-toggle').addEventListener('change', e => { devSettings.enableTrajectory = e.target.checked; saveData('orbitalGuardianDevSettings', devSettings); });
                document.getElementById('mode2-thrust-slider').addEventListener('input', e => {
                    const value = parseFloat(e.target.value);
                    devSettings.mode2ThrustMultiplier = value;
                    document.getElementById('mode2-thrust-value').textContent = `${Math.round(value * 100)}%`;
                    saveData('orbitalGuardianDevSettings', devSettings);
                });
                document.getElementById('asteroid-amount-slider').addEventListener('input', e => {
                    const value = parseFloat(e.target.value);
                    devSettings.asteroidAmountMultiplier = value;
                    document.getElementById('asteroid-amount-value').textContent = `${Math.round(value * 100)}%`;
                    saveData('orbitalGuardianDevSettings', devSettings);
                });
                document.getElementById('speed-regulator-slider').addEventListener('input', e => {
                    const value = parseFloat(e.target.value);
                    devSettings.speedRegulator = value;
                    document.getElementById('speed-regulator-value').textContent = `${Math.round(value * 100)}%`;
                    saveData('orbitalGuardianDevSettings', devSettings);
                });
            }

            function resizeCanvas() {
                devicePixelRatio = window.devicePixelRatio || 1;
                const rect = gameWrapper.getBoundingClientRect();
                canvas.width = rect.width * devicePixelRatio; canvas.height = rect.height * devicePixelRatio;
                canvas.style.width = `${rect.width}px`; canvas.style.height = `${rect.height}px`;
                scaleFactor = rect.width / WORLD_WIDTH; WORLD_HEIGHT = rect.height / scaleFactor;
                ctx.scale(devicePixelRatio, devicePixelRatio);
                if (gameState !== 'menu') draw();
                this.stars = null;
            }

            init();
        });
    </script>
</body>
</html>